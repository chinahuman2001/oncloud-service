module.exports = Object.assign ( watch, {
    flags: [ '--debug', '--in-memory', '--in-memory?' ],
    options: [ '--port', '--ext' ],
    help: `
# SYNOPSIS

    *cds watch* [<project>]

    Tells cds to watch for relevant things to come or change in the specified
    project or the current work directory. Compiles and (re-)runs the server
    on every change detected, using the open-source package _nodemon_.

# OPTIONS

    *--port* <number>

        Specify the port on which the launched server listens.
        If you specify '0', the server picks a random free port.
        Alternatively, specify the port using env variable _PORT_.

    *--ext* <extensions>

        Specify file extensions to watch for in a comma-separated list.
        *Example:* cds w --ext cds,json,js.

# SEE ALSO

    Actually, *cds watch* is just a convenient shortcut for:
    *cds serve* --with-mocks --in-memory? --watch [--project <project>] ...
    Check out *cds serve ?* to learn more.

`})

const path = require ('path')
const t = module.exports.codes = {
    reset: '\x1b[0m', // Default
    bold: '\x1b[1m', // Bold/Bright
    link: '\x1b[4m', // underline
    red: '\x1b[91m', // Bright Foreground Red
    green: '\x1b[32m', // Foreground Green
    yellow: '\x1b[33m', // Foreground Green
    orange: '\x1b[38;2;255;140;0m' // darker orange, works with bright and dark background
}
const extDefaults = 'cds,csn,csv,ts,mjs,cjs,js,json,properties,edmx,xml,env'

function watch ([folder], {
    ext = extDefaults,
    args = ['serve', 'all', '--with-mocks'],
    ...etc
}={}) {
    if (typeof ext !== 'string')  ext = extDefaults
    const inMemArg = Object.keys(etc).find(a => /^in-memory\??$/.test(a))
    args.push(inMemArg ? `--${inMemArg}` : '--in-memory?')
    if ('port' in etc) args.push('--port',etc.port)
    let watchDelay = parseInt(process.env.CDS_WATCH_DELAY) || 200

    const log = (first,...more) => console.log (t.yellow + (first||''), ...more, t.reset)
    if (folder) {
        const cwd = process.env._original_cwd = process.cwd()
        try {
            process.chdir (folder)
            log (`cd ${folder}`)
        } catch(e){
            try {
                const resolved = path.dirname (require.resolve(folder+'/package.json', {paths: [process.cwd()]}))
                log (`cd ${path.relative(cwd,resolved)}`)
                process.chdir (resolved)
            }
            catch(_){ throw e }
        }
        process.on('exit', ()=> process.chdir (process.env._original_cwd))
    }
    log ()
    log (`${t.bold}cds ${args.join(' ')}`)
    log (`( watching: ${ext}... with ${watchDelay}ms delay)`)
    let delayed = undefined
    const env = Object.assign (process.env, {
        NODE_PATH: path.resolve (__dirname, '../node_modules'), // allow global sqlite to be resolved
        _args: JSON.stringify(args),
        _original_cwd: process.env._original_cwd,
    })
    const nodemon = require('../lib/unlike-nodemon')
    return nodemon ({watch: ['*','.env','.cdsrc.json'], ext, script:__filename, env, delay:watchDelay, options:etc}
    ).on('restart', (files)=>{
        clearTimeout (delayed)
        delayed = setTimeout(()=>{
            log (`${t.bold}        _______________________\n`)
            if (files) for (let each of files) {
                const [,ext] = /\.(\w+)$/.exec(each) || []
                for (let handle of FileHandlers [ext] || [])  handle (each)
            }
        }, 111)}
    ).on('quit', ()=>{
        log (`${t.bold+t.green}\n[cds] - my watch has ended.\n`)
        process.exit()
    }).on('message', msg => {
        if (msg && msg.code === 'EADDRINUSE') {
          console.error (`\n${t.red+t.bold}[ERROR]${t.reset} EADDRINUSE - port ${msg.port} is already in use.  Restart with new port? (Y/n)`)
          env.PORT = (msg.port ? msg.port+1 : 0)
        }
        else console.error (msg)
    })
}


const FileHandlers = {
    edmx: [ file => (FileHandlers._import || (FileHandlers._import = require ('./import'))) (file) ]
}

if (!module.parent) { // launched by nodemon
    process.env._cds_watch = true
    // run through cli in order to use its error handling
    return require('./cds') (...JSON.parse(process.env._args))
}
